# 位宽优化脚本 V2 完整使用指南

## 概述

`bitwidth_optimization_v2.py` 是完全重写的位宽优化脚本，解决了之前版本的假性优化问题，实现了智能搜索策略和鲁棒性增强。

## 核心特性

### 1. 精确变量选择
- ✅ **只优化45个typedef变量**：自动从MyComplex_1.h提取typedef定义
- ✅ **排除子函数变量**：忽略_subfunc_前缀的局部变量
- ✅ **避免假性优化**：不生成未使用变量的定义

### 2. 智能两阶段搜索

#### 小数位优化（固定整数位=8）
```
起始: W=40, I=8 (小数32位)

阶段1 - 跳跃搜索:
  40 → 36 → 32 → 28 → ... (每次-4 bits)
  ↓
  BER超阈值？
  ↓
阶段2 - 精细搜索:
  从上一个成功值开始逐bit减少
  找到最优小数位宽
```

#### 整数位优化（固定小数位=已优化值）
```
起始: I=8

每次减少2 bits:
  8 → 6 → 4 (下限)
  ↓
  BER超阈值时停止
  ↓
找到最优整数位宽
```

### 3. 鲁棒性增强
所有变量的最终结果 **自动增加2位小数**：
- 原因：避免边界数值问题和NaN错误
- 效果：提供更好的容错空间
- 例如：优化得到W=30，最终输出W=32

## 使用方法

### 基本用法

```bash
# 1. 确保在HLS源文件目录
cd /home/ggg_wufuqi/hls/MIMO_detect-main/mimo_cpp_gai

# 2. 加载Vitis HLS环境
v24.2

# 3. 运行优化（4×4 16QAM示例）
python3 PYTHON_COPILOT/bitwidth_optimization_v2.py \
    --nt 4 --nr 4 --modulation 16 --snr 25 \
    --ber-threshold 0.01
```

### 参数说明

#### 必需参数
- `--nt`: 发送天线数（4/8/16/32/64）
- `--nr`: 接收天线数（4/8/16/32/64）
- `--modulation`: 调制阶数（4/16/64）
- `--snr`: 信噪比（dB）

#### 可选参数
- `--ber-threshold`: BER阈值（默认0.01，即1%）
- `--header`: MyComplex_1.h路径（默认当前目录）
- `--template`: Jinja2模板路径（默认sensitivity_types.hpp.jinja2）
- `--output-dir`: 输出目录（默认bitwidth_result/）
- `--data-path`: 测试数据路径
- `--gaussian-noise-path`: 高斯噪声文件路径
- `--order`: 优化顺序（high_to_low或low_to_high）

### 输出文件

脚本会生成两个输出文件：

1. **JSON配置文件** (`bitwidth_config_4_4_16QAM_SNR25.json`)
```json
{
  "timestamp": "2026-01-13 12:00:00",
  "baseline_ber": 0.001234,
  "ber_threshold": 0.01,
  "variables": {
    "step_size": {
      "initial_W": 40,
      "initial_I": 8,
      "optimal_W": 22,
      "optimal_I": 6,
      "reduction": 18
    },
    ...
  }
}
```

2. **优化头文件** (`MyComplex_optimized_4_4_16QAM_SNR25.h`)
```cpp
#pragma once
#include "ap_fixed.h"
#include "ap_int.h"
#include "hls_math.h"
#include "hls_stream.h"

// 自动生成的优化位宽定义

// 变量: step_size (W=22, I=6)
typedef ap_fixed<22, 6> step_size_t;

// 变量: r_norm (W=24, I=8)
typedef ap_fixed<24, 8> r_norm_t;

...
```

## 优化流程详解

### 第1步：解析头文件
```
解析MyComplex_1.h
  ↓
提取所有typedef ap_fixed定义
  ↓
排除_subfunc_前缀变量
  ↓
初始化45个变量配置 (W=40, I=8)
```

### 第2步：获取基准BER
```
使用初始位宽 W=40, I=8
  ↓
运行Vitis HLS Csim
  ↓
提取基准BER值
  ↓
作为后续优化的参考
```

### 第3步：逐变量优化
```
对每个变量:
  ┌─────────────────────────┐
  │ 3.1 小数位优化          │
  │   - 跳跃搜索 (每次-4)   │
  │   - 精细搜索 (每次-1)   │
  │   - 找到最优小数位宽    │
  └─────────────────────────┘
           ↓
  ┌─────────────────────────┐
  │ 3.2 整数位优化          │
  │   - 从I=8开始           │
  │   - 每次减少2 bits      │
  │   - 下限I=4             │
  └─────────────────────────┘
           ↓
  ┌─────────────────────────┐
  │ 3.3 清理中间日志        │
  │   - 删除TCL/LOG文件     │
  │   - 节省磁盘空间        │
  └─────────────────────────┘
```

### 第4步：鲁棒性增强
```
对所有变量:
  最优W = 优化W + 2
  (增加2位小数)
```

### 第5步：保存结果
```
生成JSON配置文件
  ↓
生成优化头文件
  ↓
打印最终汇总表
```

## 实时输出示例

### 初始化阶段
```
======================================================================
  开始位宽优化
======================================================================

解析头文件: MyComplex_1.h
  初始位宽: W=40, I=8
  找到 45 个typedef变量（已排除子函数变量）
    1. step_size: W=40, I=8
    2. r_norm: W=40, I=8
    3. r_norm_survivor: W=40, I=8
    4. lr: W=40, I=8
    5. r_norm_prop: W=40, I=8
    ... 还有 40 个变量

======================================================================
  获取基准BER (W=40, I=8)
======================================================================
  基准BER = 0.00123456
======================================================================
```

### 变量优化阶段
```
████████████████████████████████████████████████████████████████████
 进度: [1/45] (2.2%)
████████████████████████████████████████████████████████████████████
⏱  已用时间: 2.5分钟
⏱  预计剩余: 107.5分钟
⏱  预计总用时: 110.0分钟

======================================================================
正在优化变量: step_size (小数位)
  初始位宽: W=40, I=8 (小数32位)
======================================================================

  阶段1: 4-bit跳跃搜索

  [1] 测试位宽 W=36 (小数28位)... BER=0.00123458, 差异=0.00000002
    ✓ 通过

  [2] 测试位宽 W=32 (小数24位)... BER=0.00123465, 差异=0.00000009
    ✓ 通过

  [3] 测试位宽 W=28 (小数20位)... BER=0.00125678, 差异=0.00002222
    ✗ BER超出阈值，停止跳跃搜索

  阶段2: 从W=32开始逐bit精细搜索

  [4] 测试位宽 W=31 (小数23位)... BER=0.00123470, 差异=0.00000014
    ✓ 通过

  [5] 测试位宽 W=30 (小数22位)... BER=0.00124890, 差异=0.00001434
    ✗ BER超出阈值，停止精细搜索

  小数位优化完成:
    最优位宽: W=31, I=8 (小数23位)
    位宽减少: 9 bits (22.5%)
======================================================================

======================================================================
正在优化变量: step_size (整数位)
  当前位宽: W=31, I=8 (小数23位)
======================================================================

  [1] 测试位宽 W=29, I=6... BER=0.00123460, 差异=0.00000004
    ✓ 通过

  [2] 测试位宽 W=27, I=4... BER=0.00123465, 差异=0.00000009
    ✓ 通过

  整数位优化完成:
    最优位宽: W=27, I=4 (小数23位)
    总减少: 13 bits
======================================================================

  清理完成: 删除了6个日志文件
```

### 最终汇总
```
======================================================================
  增强鲁棒性: 所有变量增加2位小数
======================================================================
  step_size: W=27 → W=29
  r_norm: W=24 → W=26
  ...

================================================================================
                    所有变量最优位宽汇总
================================================================================
变量名                               原始(W,I)       优化后(W,I)     减少      
--------------------------------------------------------------------------------
✓ step_size                         (40,8)          (29,4)          11 bits
✓ r_norm                            (40,8)          (26,8)          14 bits
✓ r_norm_survivor                   (40,8)          (18,6)          22 bits
...
--------------------------------------------------------------------------------
总位宽减少: 675 bits
平均减少: 15.0 bits/变量 (37.5%)
================================================================================

配置已保存: bitwidth_result/bitwidth_config_4_4_16QAM_SNR25.json
头文件已生成: bitwidth_result/MyComplex_optimized_4_4_16QAM_SNR25.h

======================================================================
  优化完成!
======================================================================
```

## 使用优化结果

### 方法1：直接替换（测试用）
```bash
# 备份原文件
cp MyComplex_1.h MyComplex_1.h.backup

# 使用优化结果
cp bitwidth_result/MyComplex_optimized_4_4_16QAM_SNR25.h MyComplex_1.h

# 注意：还需要手动更新MHGD_accel_hw.h中的参数！
```

### 方法2：对比分析（推荐）
```bash
# 1. 查看JSON配置，分析哪些变量减少最多
cat bitwidth_result/bitwidth_config_4_4_16QAM_SNR25.json

# 2. 对比原始和优化头文件
diff MyComplex_1.h bitwidth_result/MyComplex_optimized_4_4_16QAM_SNR25.h

# 3. 选择性应用关键变量的优化
#    （特别是减少超过10 bits的变量）
```

## 注意事项

### 1. 运行环境
- ✅ 必须在HLS源文件目录运行
- ✅ 必须加载Vitis HLS环境 (v24.2)
- ✅ 确保MyComplex_1.h、MHGD_accel_hw.cpp等文件存在

### 2. MIMO配置一致性
**重要**：使用优化结果时，必须手动确保以下参数一致：

#### MHGD_accel_hw.h中的参数
```cpp
static const int Ntr_1 = 4;      // 必须匹配nt/nr
static const int mu_1 = 4;       // 必须匹配log2(modulation)
static const int mu_double = 16; // 必须匹配modulation
```

#### main_hw.cpp中的数据路径
```cpp
char bits_file[1024] = "/home/.../4_4_16QAM/reference_file/bits_SNR=";
char H_file[1024] = "/home/.../4_4_16QAM/input_file/H_SNR=";
char y_file[1024] = "/home/.../4_4_16QAM/input_file/y_SNR=";
```

#### x_initialize函数中的星座点
根据调制方式修改目标星座点。

### 3. 优化时间
- 单个变量：约2-5分钟（取决于位宽范围）
- 45个变量：约90-225分钟（1.5-3.75小时）
- 使用跳跃搜索可节省约50%时间

### 4. BER阈值选择
- 默认0.01（1%）：适合大多数情况
- 更严格0.001（0.1%）：需要更保守的位宽
- 更宽松0.05（5%）：允许更激进的位宽减少

## 故障排除

### 问题1：无法获取基准BER
**原因**：Vitis HLS未正确配置或测试数据路径错误

**解决**：
```bash
# 检查vitis_hls
which vitis_hls

# 加载环境
v24.2

# 检查测试数据
ls /home/ggg_wufuqi/hls/MHGD/MHGD/4_4_16QAM/
```

### 问题2：优化结果出现NaN警告
**原因**：MHGD_accel_hw.h参数未同步或位宽过度优化

**解决**：
1. 检查MHGD_accel_hw.h中的Ntr_1、mu_1、mu_double
2. 使用更严格的BER阈值重新优化
3. 手动增加关键变量的位宽（如H_real, H_imag等）

### 问题3：优化速度太慢
**解决**：
- 使用更宽松的BER阈值（如0.05）
- 只优化关键变量（修改脚本的变量列表）
- 使用更大的跳跃步长（修改脚本中的4改为8）

## 对比：V1 vs V2

| 特性 | V1 (旧版) | V2 (新版) |
|------|-----------|-----------|
| 变量选择 | 优化所有变量（含子函数） | 只优化45个typedef |
| 搜索策略 | 固定步长-2 | 智能跳跃+精细 |
| 搜索效率 | 慢（约400次测试） | 快（约200次测试） |
| 鲁棒性 | 无额外保证 | +2位小数增强 |
| 假性优化 | 可能存在 | 已消除 |

## 总结

`bitwidth_optimization_v2.py` 是完全重构的位宽优化工具，通过智能搜索策略和鲁棒性增强，提供了可靠、高效的位宽优化解决方案。

**关键优势**：
- ✅ 避免假性优化
- ✅ 搜索效率提升50%
- ✅ 结果更可靠（+2位小数）
- ✅ 完善的日志管理

**推荐用于**：
- 首次位宽优化
- 需要可靠结果的生产环境
- 大规模MIMO配置优化
